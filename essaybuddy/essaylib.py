import logging
from pathlib import Path
from string import Template
from typing import TypedDict

from llmlib import OpenAIConnection, check_completion, request_completion
from prompts.essay import prompt_msg, system_msg

log = logging.getLogger(__name__)


class EssayOptions(TypedDict):
    """Required essay options."""

    author: str
    audience: str
    essay_type: str
    tone: str


class Essay:
    """A class used to represent and manipulate an essay document.

    Attributes
    ----------
    path : pathlib.Path
        The path to the essay document.

    Methods
    -------
    load()
        Loads the content of the essay document from a file.
    save(content)
        Saves the provided content to the essay document file.

    """

    def __init__(
        self,
        doc_path: str = "current.md",
    ) -> None:
        """Initialize the Essay class.

        Parameters
        ----------
        essay_options : EssayOptions
            The options for the essay.

        doc_path : str, optional
            The path to the document file relative to the ./data directory.
            Default is "current.md".

        """

        self.path = Path(f"./data/{doc_path}")

    def load(self) -> str:
        """Load the content of the essay document from a file.

        Checks if the file exists. If not, an empty string is returned.

        Returns
        -------
        str
            The content of the essay document if it exists and is a text file;
            otherwise, an empty string.

        """

        # Check if the file exists
        if not self.path.is_file():
            _msg = f"File not found: {self.path.as_posix()}"
            log.info(_msg)
            return ""

        # Load the file
        with self.path.open() as _file:
            _content = _file.read()

        return _content

    def save(self, content: str) -> None:
        """Save the provided content to the essay document file.

        Parameters
        ----------
        content : str
            The content to be saved to the essay document file.

        """

        # Save the file
        with self.path.open("w") as _file:
            _file.write(content)


def run_request(
    essay_text: str,
    essay_options: EssayOptions,
    open_ai_key: str,
    model: str,
) -> str:
    """Process a given essay text using a language model.

    Parameters
    ----------
    essay_text : str
        The input essay text to be processed.

    essay_options : TypedDict
        A dictionary containing options for the essay processing, including:
        - author: The author of the essay.
        - audience: The intended audience for the essay.
        - essay_type: The type of essay being written.
        - tone: The tone of the essay.

    open_ai_key : str
        The API key for accessing the OpenAI language model.

    model : str
        The name of the language model to be used for processing the essay.

    Returns
    -------
    str
        The output response generated by the language model.

    Notes
    -----
    This function performs the following steps:

    1. Sets the system message for the language model.
    2. Substitutes the essay text into the user message template.
    3. Constructs a list of messages containing the system and user messages.
    4. Initializes an OpenAIConnection object with the provided API key.
    5. Calls the request_completion function to generate a response from
       the language model.

    """
    assert isinstance(essay_text, str), "essay_text should be a string"
    assert isinstance(essay_options, dict), "essay_options should be a dictionary"
    assert "author" in essay_options, "essay_options should contain 'author'"
    assert "audience" in essay_options, "essay_options should contain 'audience'"
    assert "essay_type" in essay_options, "essay_options should contain 'essay_type'"
    assert "tone" in essay_options, "essay_options should contain 'tone'"

    _system_msg = system_msg  # this will be a template later.
    _essay = essay_text  # this seems superflous, TODO: remove?
    _user_msg = Template(prompt_msg).substitute(essay_txt=_essay, **essay_options)
    messages = [
        {
            "role": "system",
            "content": _system_msg,
        },
        {
            "role": "user",
            "content": _user_msg,
        },
    ]

    _oaiconn = OpenAIConnection(
        api_key=open_ai_key,
    )

    _content = request_completion(
        oaiconn=_oaiconn,
        messages=messages,
        model=model,
    )

    assert isinstance(_content, str), "_content should be a string"

    if not check_completion(
        oaiconn=_oaiconn,
        completion_text=_content,
        model=model,
    ):
        _msg = "Completion check failed"
        log.error(_msg)
        raise ValueError(_msg)
    return _content
