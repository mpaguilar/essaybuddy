import logging
import os
from string import Template
from typing import TypedDict

import streamlit as st
import tomlkit
from essaytxt import essay_txt
from llmlib import OpenAIConnection, request_completion
from prompts.essay import prompt_msg, system_msg

logging.basicConfig(level=logging.DEBUG)

# Set these to WARNING to reduce noise in the logs
_set_to_warning_level = [
    "httpcore",
    "httpx",
    "urllib3",
    "openai",
    "watchdog",
]

for _logger_name in _set_to_warning_level:
    logging.getLogger(_logger_name).setLevel(logging.WARNING)

log = logging.getLogger(__name__)

open_ai_key = os.getenv("OPENAI_API_KEY")
if open_ai_key is None:
    _msg = "OPENAI_API_KEY environment variable not set"
    log.error(_msg)
    raise ValueError(_msg)


class EssayOptions(TypedDict):
    """Required essay options."""

    author: str
    audience: str
    essay_type: str
    tone: str


def get_config(config_file: str = "easybuddy.toml") -> dict:
    """Load and validate the configuration from a TOML file.

    Parameters
    ----------
    config_file : str, optional
        The path to the TOML configuration file. Default is "easybuddy.toml".

    Returns
    -------
    dict
        A dictionary containing the validated configuration options.

    Raises
    ------
    ValueError
        If the required configuration options are not found in the TOML file.

    Notes
    -----
    This function performs the following steps:
    1. Load the configuration from the specified TOML file.
    2. Check if the "prompt_options" section exists in the configuration.
    3. Validate and extract the "authors", "audiences", "essay_types", and "essay_tones"
    4. Return a dictionary containing the validated configuration options.

    """
    with open(config_file) as _toml:
        _config = tomlkit.load(_toml)

    if not _config["prompt.options"]:
        _msg = f"prompt.options not found in {config_file}"
        log.error(_msg)
        raise ValueError(_msg)

    _prompt_options = _config["prompt.options"]

    # "I am a..."
    if not _prompt_options.get("authors"):
        _msg = "authors not found in easybuddy.toml"
        log.error(_msg)
        raise ValueError(_msg)

    _author_options = _prompt_options["authors"]

    # "I am writing for..."
    if not _prompt_options.get("audiences"):
        _msg = "audiences not found in easybuddy.toml"
        log.error(_msg)
        raise ValueError(_msg)

    _audience_options = _prompt_options["audiences"]

    # "I am writing..."
    if not _prompt_options.get("essay_types"):
        _msg = "essay_types not found in easybuddy.toml"
        log.error(_msg)
        raise ValueError(_msg)

    _type_options = _prompt_options["essay_types"]

    # "The tone should be..."
    if not _prompt_options.get("essay_tones"):
        _msg = "essay_tones not found in easybuddy.toml"
        log.error(_msg)
        raise ValueError(_msg)

    _tone_options = _prompt_options["essay_tones"]

    return {
        "author_options": _author_options,
        "audience_options": _audience_options,
        "type_options": _type_options,
        "tone_options": _tone_options,
    }


def run_request(
    essay_text: str,
    essay_options: EssayOptions,
) -> str:
    """Process a given essay text using a language model.

    Parameters
    ----------
    essay_text : str
        The input essay text to be processed.

    essay_options : TypedDict, optional
        A dictionary containing options for the essay processing, including:
        - author: The author of the essay.
        - audience: The intended audience for the essay.
        - essay_type: The type of essay being written.
        - tone: The tone of the essay.

    Returns
    -------
    str
        The output response generated by the language model.

    Notes
    -----
    This function performs the following steps:

    1. Sets the system message for the language model.
    2. Substitutes the essay text into the user message template.
    3. Constructs a list of messages containing the system and user messages.
    4. Initializes an OpenAIConnection object with the provided API key.
    5. Calls the request_completion function to generate a response from
       the language model.

    """
    assert isinstance(essay_text, str), "essay_text should be a string"
    assert isinstance(essay_options, dict), "essay_options should be a dictionary"
    assert "author" in essay_options, "essay_options should contain 'author'"
    assert "audience" in essay_options, "essay_options should contain 'audience'"
    assert "essay_type" in essay_options, "essay_options should contain 'essay_type'"
    assert "tone" in essay_options, "essay_options should contain 'tone'"

    _system_msg = system_msg  # this will be a template later.
    _essay = essay_text  # this seems superflous, TODO: remove?
    _user_msg = Template(prompt_msg).substitute(essay_txt=_essay, **essay_options)
    messages = [
        {
            "role": "system",
            "content": _system_msg,
        },
        {
            "role": "user",
            "content": _user_msg,
        },
    ]

    _oaiconn = OpenAIConnection(
        api_key=open_ai_key,
    )

    with st.spinner("Working on it..."):
        _content = request_completion(
            oaiconn=_oaiconn,
            messages=messages,
        )

    assert isinstance(_content, str), "_content should be a string"
    return _content


def st_go() -> None:
    """Run the main Streamlit app."""

    _config: dict = get_config()

    assert isinstance(_config, dict), "_config should be a dictionary"

    # Set the page title and icon
    st.set_page_config(page_title="Essay Buddy", page_icon=":pencil2:", layout="wide")

    _content = "### Results will show here after you submit the essay."

    col1, col2 = st.columns(2)
    _submitted = False

    with col1, st.form("essay_form"):
        _author = st.selectbox("I am a...", _config["author_options"])
        _audience = st.selectbox("I am writing for...", _config["audience_options"])
        _essay_type = st.selectbox("I am writing...", _config["type_options"])
        _tone = st.selectbox("The tone should be...", _config["tone_options"])
        _essay_text = st.text_area("Essay", value=essay_txt, height=800)
        _submitted = st.form_submit_button("Submit")

    with col2:
        if _submitted:
            _essay_options = EssayOptions(
                {
                    "author": _author,
                    "audience": _audience,
                    "essay_type": _essay_type,
                    "tone": _tone,
                },
            )
            _content = run_request(_essay_text, essay_options=_essay_options)
        st.write(_content)


if __name__ == "__main__":
    st_go()
