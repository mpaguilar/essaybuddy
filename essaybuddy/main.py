import logging
import os
from string import Template
from typing import TypedDict

import streamlit as st
from essaytxt import essay_txt
from llmlib import OpenAIConnection, request_completion
from prompts.essay import prompt_msg, system_msg

logging.basicConfig(level=logging.DEBUG)

# Set these to WARNING to reduce noise in the logs
_set_to_warning_level = [
    "httpcore",
    "httpx",
    "urllib3",
    "openai",
    "watchdog",
]

for _logger_name in _set_to_warning_level:
    logging.getLogger(_logger_name).setLevel(logging.WARNING)

log = logging.getLogger(__name__)

open_ai_key = os.getenv("OPENAI_API_KEY")
if open_ai_key is None:
    _msg = "OPENAI_API_KEY environment variable not set"
    log.error(_msg)
    raise ValueError(_msg)


###

# "I am a..."
author_options = [
    "Technology enthusiast",
    "College student",
    "Technical writer",
    "Business Analyst",
]

# "I am writing for..."
audience_options = [
    "General audience",
    "Academic audience",
    "Technical audience",
    "Professional audience",
]

# "I am writing..."
essay_type_options = [
    "a blog post",
    "an English essay",
    "a technical document",
    "a business proposal",
]

essay_txt_tone = [
    "Formal",
    "Informal",
    "Neutral",
    "Friendly",
]

###


class EssayOptions(TypedDict):
    """Required essay options."""

    author: str
    audience: str
    essay_type: str
    tone: str


essay_option_defaults = EssayOptions(
    {
        "author": author_options[0],
        "audience": audience_options[0],
        "essay_type": essay_type_options[0],
        "tone": essay_txt_tone[0],
    },
)


def run_request(
    essay_text: str,
    essay_options: EssayOptions = essay_option_defaults,
) -> str:
    """Process a given essay text using a language model.

    Parameters
    ----------
    essay_text : str
        The input essay text to be processed.

    essay_options : TypedDict, optional
        A dictionary containing options for the essay processing, including:
        - author: The author of the essay.
        - audience: The intended audience for the essay.
        - essay_type: The type of essay being written.
        - tone: The tone of the essay.

    Returns
    -------
    str
        The output response generated by the language model.

    Notes
    -----
    This function performs the following steps:

    1. Sets the system message for the language model.
    2. Substitutes the essay text into the user message template.
    3. Constructs a list of messages containing the system and user messages.
    4. Initializes an OpenAIConnection object with the provided API key.
    5. Calls the request_completion function to generate a response from
       the language model.

    """
    assert isinstance(essay_text, str), "essay_text should be a string"
    assert isinstance(essay_options, dict), "essay_options should be a dictionary"
    assert "author" in essay_options, "essay_options should contain 'author'"
    assert "audience" in essay_options, "essay_options should contain 'audience'"
    assert "essay_type" in essay_options, "essay_options should contain 'essay_type'"
    assert "tone" in essay_options, "essay_options should contain 'tone'"

    _system_msg = system_msg  # this will be a template later.
    _essay = essay_text # this seems superflous, TODO: remove?
    _user_msg = Template(prompt_msg).substitute(essay_txt=_essay, **essay_options)
    messages = [
        {
            "role": "system",
            "content": _system_msg,
        },
        {
            "role": "user",
            "content": _user_msg,
        },
    ]

    _oaiconn = OpenAIConnection(
        api_key=open_ai_key,
    )

    with st.spinner("Working on it..."):
        _content = request_completion(
            oaiconn=_oaiconn,
            messages=messages,
        )

    assert isinstance(_content, str), "_content should be a string"
    return _content


def st_go() -> None:
    """Run the main Streamlit app."""
    # Set the page title and icon
    st.set_page_config(page_title="Essay Buddy", page_icon=":pencil2:", layout="wide")

    _content = "### Results will show here after you submit the essay."

    col1, col2 = st.columns(2)
    _submitted = False

    with col1, st.form("essay_form"):
        _author = st.selectbox("I am a...", author_options)
        _audience = st.selectbox("I am writing for...", audience_options)
        _essay_type = st.selectbox("I am writing...", essay_type_options)
        _tone = st.selectbox("The tone should be...", essay_txt_tone)
        _essay_text = st.text_area("Essay", value=essay_txt, height=800)
        _submitted = st.form_submit_button("Submit")

    with col2:
        if _submitted:
            _essay_options = EssayOptions(
                {
                    "author": _author,
                    "audience": _audience,
                    "essay_type": _essay_type,
                    "tone": _tone,
                },
            )
            _content = run_request(_essay_text, essay_options=_essay_options)
        st.write(_content)


if __name__ == "__main__":
    st_go()
